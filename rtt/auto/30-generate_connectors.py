#!/usr/bin/env python3
"""
RTT Connector Generator - SECURITY HARDENED
Generates connector stubs from manifests with security validation.
"""

import sys
from pathlib import Path

# Add tools directory to path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT / "tools"))

import validation
from config import Config
from logging_setup import setup_logging

logger = setup_logging(__name__)

MANIFESTS = Config.MANIFESTS_DIR
DRIVERS = Config.DRIVERS_DIR
OUTDIR = DRIVERS / "generated"


def stub_py(name: str, saddr: str) -> str:
    """
    Generate Python connector stub.

    Args:
        name: Connector name (sanitized)
        saddr: Symbol address

    Returns:
        Python source code
    """
    return f'''# Auto-generated connector stub (Python)
# Symbol: {saddr}
# Generated by RTT v{Config.CURRENT_VERSION}

from typing import Any, Dict, List, Optional


class Connector:
    """Connector for {saddr}"""

    def __init__(self):
        self.symbol_address = "{saddr}"

    def probe(self, root: str) -> List[Dict[str, str]]:
        """
        Probe for available symbols.

        Args:
            root: Root path to probe

        Returns:
            List of symbol descriptors
        """
        return [{{'saddr': '{saddr}'}}]

    def open(self, symbol: Dict[str, Any], params: Dict[str, Any]) -> Any:
        """
        Open connection to symbol.

        Args:
            symbol: Symbol descriptor
            params: Connection parameters

        Returns:
            Opaque handle
        """
        # TODO: Implement connection logic
        return object()

    def tx(self, handle: Any, data: bytes) -> None:
        """
        Transmit data to symbol.

        Args:
            handle: Connection handle
            data: Data to transmit
        """
        # TODO: Implement transmission logic
        pass

    def rx(self, handle: Any) -> bytes:
        """
        Receive data from symbol.

        Args:
            handle: Connection handle

        Returns:
            Received data
        """
        # TODO: Implement reception logic
        return b''

    def close(self, handle: Any) -> None:
        """
        Close connection to symbol.

        Args:
            handle: Connection handle
        """
        # TODO: Implement close logic
        pass

    def health(self, handle: Any) -> Dict[str, Any]:
        """
        Check health of connection.

        Args:
            handle: Connection handle

        Returns:
            Health status dictionary
        """
        return {{'ok': True, 'symbol': '{saddr}'}}
'''


def sanitize_connector_name(saddr: str) -> str:
    """
    Sanitize symbol address to create safe connector name.

    Args:
        saddr: Symbol address

    Returns:
        Safe filename

    Raises:
        ValidationError: If name cannot be sanitized
    """
    # Extract name from symbol address
    # Format: rtt://namespace/category/name@version#fragment
    parts = saddr.replace("rtt://", "").split("/")
    if not parts:
        raise validation.ValidationError(f"Cannot extract name from: {saddr}")

    # Get last part (name@version#fragment)
    name_part = parts[-1]

    # Remove version and fragment
    name = name_part.split("@")[0].split("#")[0]

    # Replace invalid characters
    safe_name = name.replace("-", "_").replace(".", "_").replace(":", "_")

    # Validate result
    if not safe_name or not safe_name[0].isalpha():
        safe_name = "connector_" + safe_name

    # Final validation
    validation.validate_filename(safe_name + ".py")

    return safe_name


def generate_connector(manifest_path: Path) -> tuple[str, Path]:
    """
    Generate connector from manifest.

    Args:
        manifest_path: Path to manifest file

    Returns:
        Tuple of (symbol_address, output_path)

    Raises:
        ValidationError: If validation fails
    """
    # Validate manifest path
    safe_manifest_path = validation.validate_path(
        manifest_path,
        ROOT,
        "manifest file"
    )

    # Load and validate JSON
    obj = validation.safe_json_load(safe_manifest_path)

    # Extract symbol information
    symbol_info = obj.get("symbol", {})
    saddr = symbol_info.get("saddr", "rtt://unknown")

    # Validate symbol address
    try:
        validation.validate_symbol_address(saddr)
    except validation.ValidationError as e:
        logger.warning(f"Invalid symbol address {saddr}: {e}, using anyway")

    # Sanitize name
    try:
        name = sanitize_connector_name(saddr)
    except validation.ValidationError:
        # Fallback to hash-based name
        import hashlib
        hash_value = hashlib.sha256(saddr.encode()).hexdigest()[:12]
        name = f"connector_{hash_value}"
        logger.warning(f"Using fallback name: {name}")

    # Generate stub code
    stub_code = stub_py(name, saddr)

    # Validate output filename
    output_filename = f"{name}.py"
    validation.validate_filename(output_filename)

    # Construct safe output path
    output_path = validation.validate_path(
        output_filename,
        OUTDIR,
        "connector stub"
    )

    # Write file
    output_path.write_text(stub_code, encoding="utf-8")

    logger.info(f"Generated connector: {name} for {saddr}")
    return saddr, output_path


def main():
    """Main entry point."""
    # Ensure directories exist
    OUTDIR.mkdir(parents=True, exist_ok=True)

    # Find all manifest files
    if not MANIFESTS.exists():
        logger.warning(f"Manifests directory not found: {MANIFESTS}")
        print(f"[WARN] No manifests directory at {MANIFESTS}")
        return

    manifest_files = list(MANIFESTS.glob("*.json"))

    if not manifest_files:
        logger.warning("No manifest files found")
        print(f"[WARN] No manifest files found in {MANIFESTS}")
        return

    # Generate connectors
    success_count = 0
    error_count = 0

    for manifest_file in manifest_files:
        try:
            saddr, output_path = generate_connector(manifest_file)
            print(f"[OK] {saddr} -> {output_path.name}")
            success_count += 1
        except Exception as e:
            print(f"[ERROR] {manifest_file.name}: {e}")
            logger.error(f"Failed to generate connector for {manifest_file}: {e}")
            error_count += 1

    # Summary
    print(f"[OK] generated {success_count} Python connector stubs in {OUTDIR}")
    logger.info(f"Generation complete: {success_count} success, {error_count} errors")

    if error_count > 0:
        sys.exit(1)


if __name__ == "__main__":
    main()
